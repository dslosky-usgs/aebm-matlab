function outSpec = buildSpectrum(inSpec, prefT, insert)    % inSpec: input spectrum to be expanded     %   ex. [period1   acc1; ...    %             period2   acc2; ...    %             ...]        % prefT: prefered periods to anchor the input spectrum to     % ex. [ period1; ...    %             period2; ...    %             ... ]        % insert: list of additional periods to be added to the prefT    %           used to add t_e and t_u to the output spectrum    % ex. [period1 period2 period3]        if nargin > 2        % insert additional values into the best spot        % this is how t_e and t_u can be added        for i = 1:length(insert)            val = insert(i);            idx = find(abs(prefT-val)==min(abs(prefT-val)));            prefT(idx) = val;        end    end        newT = [];    for i = 1:length(prefT)        % make new array with all inSpec and prefT values        if ~ismember(round(prefT(i), 3),round(inSpec(:,1), 3))            if length(newT) == 0                newT(1, :) = [prefT(i) -1];            else                newT(length(newT(:, 1)) + 1, :) = [prefT(i) -1];            end        end    end        % concatinate new values with the input    outSpec = vertcat(inSpec, newT);        % sort based on period    [~, sortorder] = sort(outSpec(:,1));    outSpec = outSpec(sortorder,:);        for t=1:length(outSpec)        if outSpec(t,2) == -1            % this is not a set value, find the next set value and interpolate            nextT = t + 1;            while outSpec(nextT,2) == -1 && nextT < length(outSpec)                nextT = nextT + 1;            end                    % nextPos is still undefined if it's the end of the array            if outSpec(nextT,2) == -1                outSpec(nextT,2) = .00000001;            end                        % ready to interpolate between prevT and nextT            prevT = t - 1;            step = t;            while step < nextT                %modVal = ((log(outSpec(step,1)) - log(outSpec(prevT,1))) / ...                %                    (log(outSpec(nextT,1)) - log(outSpec(prevT,1))) ...                %                   * (outSpec(nextT,2) - outSpec(prevT,2)));                if prevT > 0                    current = outSpec(step,1);                    prev = outSpec(prevT,:);                    next = outSpec(nextT,:);                    % replace zeros to avoid NaN                    if current(1) == 0                        current(1) = .00000001;                    end                    if prev(1) == 0                        prev(1) = .00000001;                    end                    if next(1) == 0                        next(1) = .00000001;                    end                    outSpec(step,2) = interp(current, ...                                            prev, ...                                            next);                    % step forward                    step = step + 1;                    prevT = prevT + 1;                end            end        end    end        % remove values not present in the prefered spectrum    filtered = [];    for i = 1:length(outSpec)        if ismember(round(outSpec(i,1), 3), round(prefT, 3))            if isempty(filtered)                filtered(1,:) = outSpec(i,:);            else                filtered(length(filtered(:,1))+1,:) = outSpec(i,:);            end        end    end        outSpec = filtered;endfunction val = interp(pos, p1, p2)    interp = (log(pos) - log(p1(1))) / ...                    (log(p2(1)) - log(p1(1))) ...                   * (p2(2) - p1(2));    val = p1(2) + interp;                                   end